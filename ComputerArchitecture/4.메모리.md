### 01. RAM

- 휘발성 저장장치
- CPU가 실행할 대상을 저장하는 부품
- RAM(Random Access Memory)
    - 임의 접근(직접 접근)
        - 저장된 요소에 순차적으로 접근할 필요 없이 곧장 접근 가능한 방식
        - 1번지에 접근하든 1000번지에 접근하든 데이터에 접근하는 시간이 동일함
    - 순차 접근
        - 순차적으로 접근하는 방식
        - 어떤 위치에 접근하느냐에 따라 데이터에 접근하는 시간이 달라질 수 있음
1. DRAM
    - Dynamic
    - 저장된 **데이터가 동적으로 변하는(사라지는)** 특성
    - 시간이 지나면 저장된 데이터가 점차 사라지는 RAM
        - 데이터의 소멸을 막기 위해 일정 주기로 데이터를 재활성화(다시 저장) 해야함
        - 소비 전력이 낮고, 저렴하며, 집적도가 높아 메모리를 대용량으로 설계하기 용이함
2. SRAM
    - Static
    - 시간이 지나도 저장된 **데이터가 사라지지 않는** RAM
    - 비휘발성 저장장치라는 것이 아님
    - 소비 전력이 크고 가격도 비싼데다 집적도도 낮기 때문에 대용량으로 만들 필요는 없지만 속도가 빨라야 하는 저장장치, **캐시 메모리** 등에서 사용됨
3. SDRAM
    - Synchronous Dynamics RAM
    - **클럭 신호와 동기화**된, 보다 발전된 형태의 DRAM
    (* SRAM과 DRAM의 합성어가 아님)
    - 클럭 타이밍에 맞춰 CPU와 정보를 주고받을 수 있는 DRAM
4. DDR SDRAM
    - Double Data Rate SDRAM
    - 대역폭을 넓혀 속도를 빠르게 만든 SDRAM
    - 대역폭
        - 데이터를 주고 받을 길의 너비
    - SDRAM이 한 클럭당 한 번씩 CPU와 데이터를 주고 받을 수 있다면, DDR SDRAM은 두 배의 대역폭으로 한 클럭당 두 번씩 CPU와 데이터를 주고 받을 수 있음
    - DDR2 SDRAM = 2*DDR SDRAM = 4*SDRAM
    DDR3 SDRAM = 2*DDR2 SDRAM = 4*DDR SDRAM = 8*SDRAM
    DDR4 SDRAM = 2*DDR3 SDRAM = 4*DDR2 SDRAM = 8*DDR SDRAM = 16*SDRAM

### 02. 메모리에 바이트를 밀어 넣는 순서 - 빅 라디안과 리틀 엔디안

- 메모리는 데이터를 **바이트 단위**로 저장하고 관리함
- 하지만 메모리는 데이터를 CPU로부터 4바이트(32비트), 혹은 8바이트(64비트)인 **워드 단위**로 받아들임
    - 16진수 1A2B3C4D는 1A, 2B, 3C, 4D로 나누어 4개의 주소에 저장됨
- 빅 엔디안
    - 낮은 번지의 주소에 상위 바이트부터 저장하는 방식
        
        ![image](https://github.com/user-attachments/assets/e79bc1c2-2c94-4aa4-85a9-dbf02f1d1144)

        
    - 장점
        - 메모리 값을 직접 읽거나 디버깅에 편함
- 리틀 엔디안
    - 낮은 번지의 주소에 하위 바이트부터 저장하는 방식
        
        ![image](https://github.com/user-attachments/assets/ed286d99-f657-40b5-8cbd-c6763e9fea91)

        
    - 장점
        - 수치 계산이 편리함
- 컴퓨터 환경에 따라 둘 중 하나로 결정되어 있는 경우도 있고, 둘 중 하나를 선택할 수 있도록 설계되어 있는 경우도 있음
이 경우는 바이 엔디안이라 함

### 03. 캐시 메모리

- CPU가 레지스터에 접근하는 속도보다 메모리에 접근하는 속도가 느림
→ CPU가 아무리 좋아도 메모리에 접근하는 속도가 느리면 소용 없음
- CPU의 연산 속도와 메모리 접근 속도의 차이를 줄이기 위한, CPU와 메모리 사이에 위치한 **SRAM 기반의 저장장치**
- 코어와 가까운 순서대로 L1 캐시, L2 캐시, L3 캐시
    - 일반적으로 L1, L2 는 코어 내부에, L3는 외부에 위치함
    - 메모리 크기 : L1 < L2 < L3
    - 속도 : L3 < L2 < L1
    - 멀티코어 프로세서의 경우
        - L1, L2 캐시는 코어마다 고유한 캐시 메모리로 할당
        - L3 캐시는 여러 코어가 공유
        - 분리형 캐시
            - L1 캐시 메모리는 L1I 캐시와 L1D 캐시로 구분하기도 함
            - L1I 캐시 : 명령어만을 저장
            - L1D 캐시 : 데이터만을 저장
            
            ![image](https://github.com/user-attachments/assets/47fb055f-3002-4111-9686-3428d533bfab)

            

- 캐시 히트와 캐시 미스
    - 캐시 메모리는 메모리의 일부, **CPU가 사용할 법한 것**을 복사하여 저장함
    - 캐시 히트
        - 캐시 메모리가 예측하여 저장한 데이터가 CPU에 실제로 사용되는 경우
    - 캐시 미스
        - 틀린 예측으로 인해 CPU가 메모리로부터 필요한 데이터를 직접 가져와야 하는 경우
    - 캐시 적중률
        - 캐시 히트 횟수 / (캐시 히트 횟수 + 캐시 미스 횟수)
- 참조 지역성의 원리
    - 캐시 적중률을 높이기 위해 CPU가 사용할 법한 데이터를 예측하는 방법
    - 시간 지역성
        - CPU는 최근에 접근했던 메모리 공간에 다시 접근하려는 경향이 있음
        - ex) 변수 → 일반적으로 변수에 저장된 값은 한 번만 사용되지 않고, 프로그램이 실행되는 동안 여러 번 사용됨
    - 공간 지역성
        - CPU는 접근한 메모리 공간의 근처에 접근하려는 경향이 있음
        - ex) 배열
            
            ```python
            # 공간 지역성 고려 O
            for i in range(20000):
            	for j in range(20000):
            		matrix[i][j] = 1
            		
            # 공간 지역성 고려 X
            for i in range(20000):
            	for j in range(20000):
            		matrix[j][i] = 1		
            ```
            
            실제 실행 시간에서 차이가 있음
            
- 캐시 메모리의 쓰기 정책과 일관성
    - CPU가 캐시 메모리에 저장되어 있는 값을 변경하고 싶을 때, 캐시 메모리를 거치지 않고 곧장 메모리의 값도 변경하는 것은 위험함.
    → 캐시 메모리를 읽어 들일 경우 일관성이 깨짐
        - **즉시 쓰기(Write Trough)**
            - 캐시 메모리와 메모리에 동시에 쓰는 방법
            - 효율이 떨어짐
            → 데이터를 쓸 때마다 메모리를 참조해야 하므로 **버스의 사용 시간**과 **쓰기 시간**이 늘어남
        - **지연 쓰기(Write Back, Write Behind)**
            - 캐시 메모리에만 값을 써 두었다가 추후 수정된 데이터를 한 번에 메모리에 반영하는 방법
            - 빠르지만, 일관성이 깨질 수 있는 위험이 있음
            다른 코어가 사용하는 메모리와의 불일치도 발생할 수 있음
            - **MESI 프로토콜**
                - 캐시 일관성 프로토콜
                - 각 캐시 블록이 가지고 있는 4가지 상태를 정의한 프로토콜
                    
                    
                    | 상태 | 설명 | 메모리와 일치? | 나만 가지고 있나? |
                    | --- | --- | --- | --- |
                    | **M (Modified)** | 내가 수정했음. 메모리는 구버전. | ❌ | ✅ |
                    | **E (Exclusive)** | 수정은 안 했지만 나만 이 데이터 갖고 있음. | ✅ | ✅ |
                    | **S (Shared)** | 다른 CPU들도 이 데이터 갖고 있음. | ✅ | ❌ |
                    | **I (Invalid)** | 유효하지 않은 데이터. | ❌ | ❌ |
                - 상태 전이 흐름
                    - 읽기 시
                        - 현재 상태: Invalid
                            - 다른 캐시에도 없음 → E 상태
                            - 다른 캐시에 있음 → S 상태
                        - 현재 상태: S, E, M
                            - 그냥 읽음
                    - 쓰기 시
                        - 현재 상태: Invalid, Shared, Exclusive
                            - → M 상태로 전이
                            - 다른 캐시에 존재할 경우 → Invalidate(무효화) 브로드캐스트
                        - 현재 상태: M
                            - 그냥 씀 (이미 나 혼자고, 메모리랑 불일치)
                - 예시 시나리오
                    - 현재 상황
                        - CPU1, CPU2가 있고, 주소 A를 공유
                        - CPU1이 A = 100 으로 값을 바꿨고, 이건 **Modified** 상태
                        - CPU2는 A를 아직 읽지 않았거나 다른 값이라서 **Invalid** 상태
                    1. CPU2가 자기 캐시에 A가 Invalid인 걸 보고
                    2. 버스를 통해 “나 A 좀 주세요!”(Bus Read) 요청을 broadcast 함
                    3. CPU1은 “어? 나 그 주소 Modified 상태로 갖고 있어!” → 응답함
                        1. 이때 CPU1은 데이터를 자기 캐시에 내보내면서 Shared 상태로 바꿈
                    4. CPU2는 그 데이터를 받아서 자기 캐시에 넣고 Shared 상태로 저장
                    - 결과적으로
                        - CPU1: Modified → Shared
                        - CPU2: Invalid → Shared
                    
                    ![image](https://github.com/user-attachments/assets/7e720977-8654-4f03-a513-74a56abc6847)

                    
    - 캐시 미스 발생 시 처리 정책
        - Write-no-allocate
            - 쓰기 중 캐시 미스 발생 시 데이터를 캐시에 올리고 씀
        - Write-allocate
            - 쓰기 중 캐시 미스 발생 시 캐시에 올리지 않고 메모리에만 씀
    - 캐시 쓰기 전략 별 실제 사용 예시
        
        
        | 조합 | 사용 위치 | 예시 |
        | --- | --- | --- |
        | Write-Back + Write-Allocate | ✅ 가장 일반적 | x86/ARM CPU 캐시 (L1/L2/L3) |
        | Write-Through + Write-No-Allocate | 🔒 신뢰성 중시 | MCU, I/O 메모리 |
        | Write-Back + Write-No-Allocate | 🎯 캐시 정제 전략 | 커널 DMA, 드라이버 |
        | Write-Through + Write-Allocate | ⚠️ 드묾 | 일부 IoT 캐시 정책 등 |
- 캐시 교체 정책
    - 캐시 메모리는 매우 제한적이고 유한함
    → 효율적인 사용이 중요
    - 이를 위해 캐시 교체 알고리즘을 사용함
        - LRU, LFU, FIFO 등 캐시 교체 알고리즘이 있음
            - ~~이후 OS 페이지 교체 알고리즘에서 똑같이 나올테니 여기선 패스~~
