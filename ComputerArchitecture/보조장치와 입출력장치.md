## 목차
- [RAID](#raid-1)
  - [RAID0](#raid0)
  - [RAID1](#raid1)
  - [RAID4](#raid4)
  - [RAID5](#raid5)
  - [RAID6](#raid6)
  - [패리티 비트의 역할](#패리티-비트의-역할)
- [입출력](#입출력-1)
  - [프로그램 입출력](#프로그램-입출력)
  - [인터럽트 기반 입출력 처리과정](#인터럽트-기반-입출력-처리과정)
  - [다중 인터럽트 처리시에 우선순위 문제](#다중-인터럽트-처리시에-우선순위-문제)
- [핵심 키워드 정리](#핵심-키워드-정리)

## RAID
+ RAID는 Redundant Arrays of Inexpensive Disks의 약자로, 여러개의 독립적인 보조기억장치를 복수로 배열하여 하나의 디스크처럼 사용하는 기술
+ RAID를 구성하는 방법에는 여러가지가 있으며, RAID 레벨로 구분한다.
+ 
### RAID0
+ 저장하고자하는 데이터를 보조기억장치에 단순하게 나누어서 저장하는 방식
+ 장점은 빠른 입출력 속도이고, 단점은 저장된 정보가 분산 저장되지 않기때문에 안전하지 않다는 것

### RAID1
+ 원본과, 원본의 완전히 복사본을 각각 저장 저장하는 구성방식
+ 문제가 생겨도 복구가 용이하다는 장점과, RAID0와 비교하여 저장 공간이 절반으로 줄어든다는 단점이 존재

### RAID4
+ 패리티 정보를 저장하는 디스크를 별도로 두는 방식 (예를 들어 4번 디스크는 패리티 비트 전용)
+ RAID 1에 비해서 저장 공간을 많이 확보하면서도 데이터 안정성을 지킬 수 있다는 장점과, 
  패리티 비트 디스크에 병목 현상이 생길 수 있다는 단점이 존재

### RAID5
+ RAID4에서 패리티 정보를 저장하는 디스크를 분산시키는 것으로 병목현상을 해결한 구조

### RAID6
+ 서로 다른 2개의 패리티를 두는 구성방식
+ 따라서 저장 가능한 공간은 RAID4, 5에 비해 줄어든다는 단점과 데이터 안정성은 올라간다는 장점이 존재

### 패리티 비트의 역할
``` 
일부 데이터가 손상됐을 때, 패리티 정보와 남아있는 디스크의 데이터를 사용하여 손실된 데이터를 수학적으로 재구성 가능함.

예를 들어, XOR 연산을 사용하는 경우:
원래 데이터 A, B, C가 있고 패리티 P = A ⊕ B ⊕ C라면,
B가 손실되었을 때 B = A ⊕ C ⊕ P로 복원 가능.

하지만 A와 B가 동시에 손상된 경우라면? P만으로는 당연히 복구 불가.
```

## 입출력

### 프로그램 입출력
+ 프로그램 입출력은 프로그램 명령어로 입축력 작업을 수행하는 방법
+ "하드디스크 내부의 number.txt에 10을 써라." 와 같은 입출력 명령어를 아래와 같이 프로그램 명령어로 작성하는 것
```
file = fopen("number.txt", "w");
fprintf(file, "%d", 10);
```
### 인터럽트 기반 입출력 처리과정

1. **인터럽트 발생**: 입출력 장치에서 발생한 요청 신호는 인터럽트 컨트롤러를 통해 인터럽트의 형태로 시스템에 전달됨.

2. **인터럽트 라우팅**: 인터럽트 컨트롤러는 다음 기준에 따라 어떤 CPU 코어가 인터럽트를 처리할지 결정함:
   - **프로세스 연관성**: "이 키보드 입력은 현재 포커스가 있는 브라우저 프로세스용이고, 해당 프로세스는 코어 2에서 실행 중이니 코어 2에 인터럽트를 보내자"
   - **하드웨어 친화도**: "코어 0은 USB 컨트롤러(키보드 연결)와 물리적으로 가까워 레이턴시가 낮으니, 코어 0에 인터럽트를 보내자"
   - **실시간 우선순위**: "코어 1은 현재 중요한 실시간 작업을 처리 중이니 방해하지 말고, 다른 코어로 인터럽트를 보내자"

3. **인터럽트 전달**: 선택된 CPU 코어에 인터럽트 신호가 전달됨.

4. **인터럽트 유형 확인**: 인터럽트를 받은 CPU 코어는 인터럽트의 유형을 확인하고 우선순위를 결정함.

5. **코어 상태 백업**: 인터럽트 처리를 위해 해당 CPU 코어는 현재 실행 중인 프로세스의 상태를 스택에 저장함.

6. **인터럽트 벡터 참조**: 해당 CPU 코어는 인터럽트 벡터 테이블을 참조하여 해당 인터럽트 번호에 대응하는 인터럽트 서비스 루틴(ISR)의 주소를 찾음.

7. **제어권 전환**: 해당 CPU 코어는 현재 실행 중인 프로세스의 제어권을 운영체제로 넘김.

8. **인터럽트 서비스 루틴 실행**: 운영체제는 해당 인터럽트에 대한 인터럽트 서비스 루틴을 해당 코어에서 실행함.

9. **관련 프로세스 확인**: 운영체제는 해당 인터럽트가 특정 프로세스와 관련이 있는지 확인함.

10. **인터럽트 핸들러 실행**: 관련 프로세스의 인터럽트 핸들러 실행 또는 시스템 수준에서 처리.

11. **인터럽트 핸들러 부재 시 처리**: 적절한 조치 수행 (프로세스 종료, 기본 핸들러 호출, 오류 기록 등).

12. **코어 상태 복원**: 인터럽트 처리 완료 후, 저장해둔 코어 상태를 복원.

13. **프로세스 실행 재개**: 중단되었던 지점부터 프로세스 실행 재개.

### 다중 인터럽트 처리시에 우선순위 문제
+ CPU는 동시다발적으로 발생하는 키보드, 마우스, 모니터, ...의 인터럽트를 모두 유연하게 처리해야한다.
+ 인터럽트가 여러 입출력장치로부터 동시다발적으로 발생하는 경우에는 우선순위를 고려하여 처리해야 한다.
+ 프로그래머블 인터럽트 컨트롤러(IPC)에서 이러한 인터럽트들의 우선순위를 판별하고, CPU에게 지금 처리해야 하는 작업을 알려준다.
+ 인터럽트 A보다 B가 우선순위가 높다면, B가 발생했을 때 A를 진행하던 중이라도 A를 중단하고 B를 모두 처리한 뒤에 A의 작업을 재개한다.

---

## 핵심 키워드 정리

### RAID 관련
- **RAID (Redundant Arrays of Inexpensive Disks)**: 여러 독립적인 보조기억장치를 하나의 디스크처럼 사용하는 기술
- **RAID0**: 데이터를 여러 디스크에 단순 분산 저장하여 속도는 빠르나 안정성이 낮음
- **RAID1**: 완전한 복사본을 별도 디스크에 저장하여 안정성이 높으나 저장 공간이 절반으로 감소
- **RAID4**: 패리티 정보를 별도 디스크에 저장하여 공간 효율성은 높으나 패리티 디스크에 병목 현상 발생
- **RAID5**: RAID4의 개선 버전으로 패리티 정보를 모든 디스크에 분산 저장하여 병목 현상 해결
- **RAID6**: 서로 다른 2개의 패리티를 사용하여 데이터 안정성이 높으나 저장 공간 효율성 감소
- **패리티 비트**: 손상된 데이터를 다른 디스크와 패리티 정보를 통해 수학적으로 복구하는 데 사용

### 입출력 관련
- **인터럽트 기반 입출력**: 입출력 장치의 요청 신호가 인터럽트 형태로 시스템에 전달되는 방식
- **인터럽트 컨트롤러**: 다양한 입출력 장치의 인터럽트를 관리하고 우선순위를 판별
- **인터럽트 서비스 루틴(ISR)**: 특정 인터럽트 처리를 위한 코드 루틴
- **다중 인터럽트 처리**: 여러 인터럽트가 동시에 발생할 때 우선순위에 따라 처리하는 메커니즘
