## 목차
- [RAID](#raid-1)
  - [RAID0](#raid0)
  - [RAID1](#raid1)
  - [RAID4](#raid4)
  - [RAID5](#raid5)
  - [RAID6](#raid6)
  - [패리티 비트의 역할](#패리티-비트의-역할)
- [입출력](#입출력-1)
  - [프로그램 입출력](#프로그램-입출력)
  - [인터럽트 기반 입출력 처리과정](#인터럽트-기반-입출력-처리과정)
  - [다중 인터럽트 처리시에 우선순위 문제](#다중-인터럽트-처리시에-우선순위-문제)
- [핵심 키워드 정리](#핵심-키워드-정리)
- [나왔던 질문](#나왔던-질문)

## RAID
+ RAID는 Redundant Arrays of Inexpensive Disks의 약자로, 여러개의 독립적인 보조기억장치를 복수로 배열하여 하나의 디스크처럼 사용하는 기술
+ RAID를 구성하는 방법에는 여러가지가 있으며, RAID 레벨로 구분한다.

### RAID0
+ 저장하고자하는 데이터를 보조기억장치에 단순하게 나누어서 저장하는 방식
+ 장점은 빠른 입출력 속도이고, 단점은 저장된 정보가 분산 저장되지 않기때문에 안전하지 않다는 것

### RAID1
+ 원본과, 원본의 완전히 복사본을 각각 저장하는 구성방식
+ 문제가 생겨도 복구가 용이하다는 장점과, RAID0와 비교하여 저장 공간이 절반으로 줄어든다는 단점이 존재

### RAID4
+ 패리티 정보를 저장하는 디스크를 별도로 두는 방식 (예를 들어 4번 디스크는 패리티 비트 전용)
+ RAID 1에 비해서 저장 공간을 많이 확보하면서도 데이터 안정성을 지킬 수 있다는 장점과, 
  패리티 비트 디스크에 병목 현상이 생길 수 있다는 단점이 존재

### RAID5
+ RAID4에서 패리티 정보를 저장하는 디스크를 분산시키는 것으로 병목현상을 해결한 구조

### RAID6
+ 서로 다른 2개의 패리티를 두는 구성방식
+ 따라서 저장 가능한 공간은 RAID4, 5에 비해 줄어든다는 단점과 데이터 안정성은 올라간다는 장점이 존재

### 패리티 비트의 역할
``` 
일부 데이터가 손상됐을 때, 패리티 정보와 남아있는 디스크의 데이터를 사용하여 손실된 데이터를 수학적으로 재구성 가능함.

예를 들어, XOR 연산을 사용하는 경우:
원래 데이터 A, B, C가 있고 패리티 P = A ⊕ B ⊕ C라면,
B가 손실되었을 때 B = A ⊕ C ⊕ P로 복원 가능.

하지만 A와 B가 동시에 손상된 경우라면? P만으로는 당연히 복구 불가.
```

## 입출력

### 프로그램 입출력
+ 프로그램 입출력은 프로그램 명령어로 입축력 작업을 수행하는 방법
+ "하드디스크 내부의 number.txt에 10을 써라." 와 같은 입출력 명령어를 아래와 같이 프로그램 명령어로 작성하는 것
```
file = fopen("number.txt", "w");
fprintf(file, "%d", 10);
```
### 인터럽트 기반 입출력 처리과정

1. **인터럽트 발생**: 입출력 장치에서 발생한 요청 신호는 인터럽트 컨트롤러를 통해 인터럽트의 형태로 시스템에 전달됨.

2. **인터럽트 라우팅**: 인터럽트 컨트롤러는 다음 기준에 따라 어떤 CPU 코어가 인터럽트를 처리할지 결정함:
   - **프로세스 연관성**: "이 키보드 입력은 현재 포커스가 있는 브라우저 프로세스용이고, 해당 프로세스는 코어 2에서 실행 중이니 코어 2에 인터럽트를 보내자"
   - **하드웨어 친화도**: "코어 0은 USB 컨트롤러(키보드 연결)와 물리적으로 가까워 레이턴시가 낮으니, 코어 0에 인터럽트를 보내자"
   - **실시간 우선순위**: "코어 1은 현재 중요한 실시간 작업을 처리 중이니 방해하지 말고, 다른 코어로 인터럽트를 보내자"

3. **인터럽트 전달**: 선택된 CPU 코어에 인터럽트 신호가 전달됨.

4. **인터럽트 유형 확인**: 인터럽트를 받은 CPU 코어는 인터럽트의 유형을 확인하고 우선순위를 결정함.

5. **코어 상태 백업**: 인터럽트 처리를 위해 해당 CPU 코어는 현재 실행 중인 프로세스의 상태를 스택에 저장함.

6. **인터럽트 벡터 참조**: 해당 CPU 코어는 인터럽트 벡터 테이블을 참조하여 해당 인터럽트 번호에 대응하는 인터럽트 서비스 루틴(ISR)의 주소를 찾음.

7. **제어권 전환**: 해당 CPU 코어는 현재 실행 중인 프로세스의 제어권을 운영체제로 넘김.

8. **인터럽트 서비스 루틴 실행**: 운영체제는 해당 인터럽트에 대한 인터럽트 서비스 루틴을 해당 코어에서 실행함.

9. **관련 프로세스 확인**: 운영체제는 해당 인터럽트가 특정 프로세스와 관련이 있는지 확인함.

10. **인터럽트 핸들러 실행**: 관련 프로세스의 인터럽트 핸들러 실행 또는 시스템 수준에서 처리.

11. **인터럽트 핸들러 부재 시 처리**: 적절한 조치 수행 (프로세스 종료, 기본 핸들러 호출, 오류 기록 등).

12. **코어 상태 복원**: 인터럽트 처리 완료 후, 저장해둔 코어 상태를 복원.

13. **프로세스 실행 재개**: 중단되었던 지점부터 프로세스 실행 재개.

### 다중 인터럽트 처리시에 우선순위 문제
+ CPU는 동시다발적으로 발생하는 키보드, 마우스, 모니터, ...의 인터럽트를 모두 유연하게 처리해야한다.
+ 인터럽트가 여러 입출력장치로부터 동시다발적으로 발생하는 경우에는 우선순위를 고려하여 처리해야 한다.
+ 프로그래머블 인터럽트 컨트롤러(IPC)에서 이러한 인터럽트들의 우선순위를 판별하고, CPU에게 지금 처리해야 하는 작업을 알려준다.
+ 인터럽트 A보다 B가 우선순위가 높다면, B가 발생했을 때 A를 진행하던 중이라도 A를 중단하고 B를 모두 처리한 뒤에 A의 작업을 재개한다.

---

## 핵심 키워드 정리

### RAID 관련
- **RAID (Redundant Arrays of Inexpensive Disks)**: 여러 독립적인 보조기억장치를 하나의 디스크처럼 사용하는 기술
- **RAID0**: 데이터를 여러 디스크에 단순 분산 저장하여 속도는 빠르나 안정성이 낮음
- **RAID1**: 완전한 복사본을 별도 디스크에 저장하여 안정성이 높으나 저장 공간이 절반으로 감소
- **RAID4**: 패리티 정보를 별도 디스크에 저장하여 공간 효율성은 높으나 패리티 디스크에 병목 현상 발생
- **RAID5**: RAID4의 개선 버전으로 패리티 정보를 모든 디스크에 분산 저장하여 병목 현상 해결
- **RAID6**: 서로 다른 2개의 패리티를 사용하여 데이터 안정성이 높으나 저장 공간 효율성 감소
- **패리티 비트**: 손상된 데이터를 다른 디스크와 패리티 정보를 통해 수학적으로 복구하는 데 사용

### 입출력 관련
- **인터럽트 기반 입출력**: 입출력 장치의 요청 신호가 인터럽트 형태로 시스템에 전달되는 방식
- **인터럽트 컨트롤러**: 다양한 입출력 장치의 인터럽트를 관리하고 우선순위를 판별
- **인터럽트 서비스 루틴(ISR)**: 특정 인터럽트 처리를 위한 코드 루틴
- **다중 인터럽트 처리**: 여러 인터럽트가 동시에 발생할 때 우선순위에 따라 처리하는 메커니즘


---

## 나왔던 질문
### 질문 1.
> 인터럽트 라우팅 시스템의 코어 분배 원리

**질문**
| 멀티코어 환경에서 인터럽트 라우팅 시스템이 특정 코어에 인터럽트 요청이 집중될 때 어떻게 처리하는지, 그리고 병렬 처리를 위해 다른 코어로 요청을 분산시키는 메커니즘이 있는지

**답변**
| 멀티코어 시스템에서 인터럽트 요청이 특정 코어에 집중될 경우, 시스템은 실시간 우선순위 산정 원칙에 따라 요청을 분산시킵니다. 이 과정에서 다음과 같은 계층적 우선순위 체계를 따릅니다:

1. 프로세스 연관성(Process Affinity) - 최우선 원칙

프로세스는 가능한 한 이전에 실행되던 동일한 코어에서 계속 실행됩니다.
이는 캐시 지역성(Cache Locality)을 유지함으로써 성능을 최적화합니다.
L1/L2 캐시 히트율을 최대화하여 메모리 접근 지연시간을 최소화합니다.
현재 활성화된(포커스가 있는) 프로세스가 실행 중인 코어에 인터럽트 요청이 우선적으로 전달됩니다.
이를 통해 문맥 전환(Context Switch) 비용을 줄이고 응답 시간을 개선합니다.

2. 하드웨어 친화도(Hardware Affinity) - 차순위 원칙

특정 하드웨어 장치와 가장 직접적으로 연결된 코어에 인터럽트를 할당합니다.
인터럽트 요청과 관련된 I/O 장치에 물리적으로 가까운 코어를 선호합니다.
NUMA(Non-Uniform Memory Access) 아키텍처에서 특히 중요한 최적화 기법입니다.
메모리 접근 지연시간과 시스템 버스 트래픽을 감소시킵니다.

3. 부하 분산(Load Balancing) - 최후 원칙

코어 간 작업 부하가 심각하게 불균형한 상황에서만 적용됩니다.
시스템 전체 처리량과 응답성을 개선하기 위한 안전장치로 기능합니다.
특정 코어의 과부하를 방지하여 전체 시스템 성능 저하를 방지합니다.
동적 인터럽트 밸런싱(Dynamic Interrupt Balancing)을 통해 실시간으로 부하를 모니터링하고 필요시 인터럽트를 재분배합니다.

이러한 우선순위 체계는 시스템의 전반적인 성능과 응답성을 최적화하면서도, 인터럽트 처리의 효율성을 보장합니다. 특정 코어에 인터럽트가 집중되더라도 시스템은 프로세스 연관성을 최우선으로 고려하되, 심각한 불균형 상황에서는 전체 시스템 성능을 위해 부하 분산 메커니즘을 활성화합니다.

### 질문 2.
> 인터럽트 서비스 루틴(ISR)과 인터럽트 핸들러의 차이

**질문**
| 인터럽트 서비스 루틴(ISR)과 인터럽트 핸들러의 차이가 정확히 무엇인지

**답변**
| 인터럽트 서비스 루틴(ISR)과 인터럽트 핸들러는 아래와 같은 차이가 있습니다.

+ **인터럽트 서비스 루틴(ISR)** :
인터럽트가 발생하면 즉시 실행되는 최우선 순위의 코드 블록입니다. ISR은 인터럽트 컨텍스트에서 실행되며, 시스템 반응성을 최대화하기 위해 짧고 간결하게 구현됩니다. 주요 임무는 인터럽트 원인 식별, 중요 데이터 저장, 그리고 필요시 인터럽트 핸들러 호출입니다.

+ **인터럽트 핸들러** :
ISR에서 시작된 작업을 이어받는 복잡한 처리 루틴입니다. 핸들러는 프로세스 컨텍스트에서 일반 프로세스와 유사하게 CPU 시간을 할당받아 실행됩니다. 따라서 메모리 할당, 파일 시스템 접근, 복잡한 데이터 처리 등 ISR에서 수행하기 어려운 작업들을 처리할 수 있습니다.

**작동 흐름**
1. 하드웨어 인터럽트 발생
2. CPU가 현재 작업을 즉시 일시 중단하고 ISR 실행
3. ISR은 필수적인 즉각 대응 후 신속히 종료
4. 추가 처리가 필요하면 인터럽트 핸들러를 스케줄링
5. 인터럽트 핸들러는 일반 태스크로서 스케줄러에 의해 실행

이러한 이원화 설계는 시스템의 즉각적인 응답성을 유지하면서도 복잡한 인터럽트 처리를 효율적으로 관리하기 위한 최적의 접근 방식입니다. ISR이 신속한 대응을 담당하고, 핸들러가 더 세부적인 처리를 맡음으로써 시스템의 인터럽트 처리 성능과 전체적인 안정성이 향상됩니다.
